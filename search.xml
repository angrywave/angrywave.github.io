<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[music]]></title>
    <url>angrywave.github.io%2Fmusic%2F</url>
    <content type="text"><![CDATA[var ap = new APlayer({ element: document.getElementById("aplayer-QTlNFIGn"), narrow: false, autoplay: false, showlrc: false, music: { title: "晴天", author: "Jay", url: "qingtian.mp3", pic: "", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);]]></content>
      <categories>
        <category>Entertainment</category>
      </categories>
      <tags>
        <tag>music</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[demo]]></title>
    <url>angrywave.github.io%2Fdemo%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>demo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[golang-learning]]></title>
    <url>angrywave.github.io%2FGolang%2F</url>
    <content type="text"><![CDATA[Go basicspackages manage在 gopath文件夹下 go get github.com/vmihailenco/redis 回车之后会自动下载项目到GOPATH中的src目录下。 缓存sync.Map123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263sync.Map 源码解析 type Map struct &#123; // 该锁用来保护dirty mu Mutex // 存读的数据，因为是atomic.value类型，只读类型，所以它的读是并发安全的 read atomic.Value // readOnly //包含最新的写入的数据，并且在写的时候，会把read 中未被删除的数据拷贝到该dirty中，因为是普通的map存在并发安全问题，需要用到上面的mu字段。 dirty map[interface&#123;&#125;]*entry // 从read读数据的时候，会将该字段+1，当等于len（dirty）的时候，会将dirty拷贝到read中（从而提升读的性能）。 misses int&#125;--------------------- https://blog.csdn.net/u010230794/article/details/82143179 https://www.jianshu.com/p/671eb4245c28package main import ( "fmt" "sync") func main() &#123; var m sync.Map //Store m.Store(1,"a") m.Store(2,"b") //LoadOrStore //若key不存在，则存入key和value，返回false和输入的value v,ok := m.LoadOrStore("1","aaa") fmt.Println(ok,v) //false aaa //若key已存在，则返回true和key对应的value，不会修改原来的value v,ok = m.LoadOrStore(1,"aaa") fmt.Println(ok,v) //false aaa //Load v,ok = m.Load(1) if ok&#123; fmt.Println("it's an existing key,value is ",v) &#125; else &#123; fmt.Println("it's an unknown key") &#125; //Range //遍历sync.Map, 要求输入一个func作为参数 f := func(k, v interface&#123;&#125;) bool &#123; //这个函数的入参、出参的类型都已经固定，不能修改 //可以在函数体内编写自己的代码，调用map中的k,v fmt.Println(k,v) return true &#125; m.Range(f) //Delete m.Delete(1) fmt.Println(m.Load(1)) &#125; 通过interface实现多态123456789101112131415161718192021222324252627282930313233343536373839404142434445464748https://www.bilibili.com/video/av36036183/?p=105 美女老师带你学go语言type Shape interface&#123; peri() float64 area() float64&#125;// 类 Circle 实现了 Shape 的方法， 因此 是 接口Shape 的实现类 type Circle struct&#123; radius float64&#125;func (c Circle)peri()&#123; return c.redius*2*math.Pi&#125;func (c Circle) area()&#123; return math.Pow(c.redius, 2)*math.Pi&#125;// 向下转型var s1 Shape = Circle&#123;redius:2&#125; // 声明为接口类型 并 创建实现类对象 // var v1 interface = 实现类对象 只能访问方法// var v2 实现类 = 实现类对象 可以访问方法和属性interface 用法1 函数如果接受接口类型作为参数 ， 那么可以传入 该接口的任意实现类作为参数2 定义一个类型为接口 ， 那可以 被赋值为 该接口的任意 实现类 对象 定义一个接口类型的容器 ， 它可以存储 任意的实现类对象arr := [4]Shape&#123;t1,s1,c1,t2&#125;// 向上转型func getType(s Shape)&#123; // instance , ok := 接口对象.（实现类） if ins, ok := s.(Circle); ok&#123; fmt.printf(ins) &#125;&#125;func getType(s Shape)&#123; switch ins := s.(type)&#123; case Circle: pass &#125;&#125; JSON序列化123456789101112131415161718192021222324252627282930313233343536373839404142将数据编码成json字符串 json.Marshal()type Stu struct &#123; Name string `json:"name"` Age int HIgh bool sex string Class *Class `json:"class"`&#125;type Class struct&#123; Name string Grade int&#125;cla := new(Class) //指针变量cla.Name = "1班"cla.Grade = 3stu.Class=cla //实例化一个数据结构，用于生成json字符串 stu := Stu&#123; Name: "张三", Age: 18, HIgh: true, sex: "男", &#125;jsonStu, err := json.Marshal(stu)//jsonStu是[]byte类型，转化成string类型便于查看 string(jsonStu)if err != nil &#123; fmt.Println("生成json字符串错误")&#125;只要是可导出成员（变量首字母大写），都可以转成json。因成员变量sex是不可导出的，故无法转成json。如果变量打上了json标签，如Name旁边的 `json:"name"` ，那么转化成的json key就用该标签“name”，否则取变量名作为key，如“Age”，“HIgh”。bool类型也是可以直接转换为json的value值。Channel， complex 以及函数不能被编码json字符串。当然，循环的数据结构也不行，它会导致marshal陷入死循环。指针变量，编码时自动转换为它所指向的值，如cla变量。 （当然，不传指针，Stu struct的成员Class如果换成Class struct类型，效果也是一模一样的。只不过指针更快，且能节省内存空间。）最后，强调一句：json编码成字符串后就是纯粹的字符串了。原文：https://blog.csdn.net/zxy_666/article/details/80173288 ###反序列化 123456789101112131415// 1 func Unmarshal(data []byte, v interface&#123;&#125;) error// Use json.Unmarshal if you already have the JSON data in memory.data, err := ioutil.ReadAll(resp.Body)if err == nil &amp;&amp; data != nil &#123; err = json.Unmarshal(data, value)&#125;//Use json.Decoder if your data is coming from an io.Reader stream, or you need to decode multiple values from a stream of data.//For the case of reading from an HTTP request, I’d pick json.Decoder since you’re obviously reading from a stream.原文：https://blog.csdn.net/jason_cuijiahui/article/details/84566387 // 2 func NewDecoder(r io.Reader) *Decoder// func (dec *Decoder) Decode(v interface&#123;&#125;) errorerr = json.NewDecoder(resp.Body).Decode(value) Beegohttps://www.jianshu.com/p/b729ff1f6f9e bee new project bee api apiproject gorm http://gorm.book.jasperxu.com/models.html#md 1234567https://www.jianshu.com/p/a40a79f1915fhttps://www.jianshu.com/p/f7419395e4ccif err := db.Set(&quot;gorm:table_options&quot;, &quot;ENGINE=InnoDB DEFAULT CHARSET=utf8&quot;).CreateTable(&amp;User&#123;&#125;,&amp;Video_info&#123;&#125;).Error; err != nil &#123; panic(err)&#125; ##CRUD 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394package main import ( "database/sql" "fmt" _ "github.com/go-sql-driver/mysql") func main() &#123; db, err := sql.Open("mysql", "root:wangshubo@/test?charset=utf8") checkErr(err) // insert stmt, err := db.Prepare("INSERT user_info SET id=?,name=?") checkErr(err) res, err := stmt.Exec(1, "wangshubo") checkErr(err) // update stmt, err = db.Prepare("update user_info set name=? where id=?") checkErr(err) res, err = stmt.Exec("wangshubo_update", 1) checkErr(err) affect, err := res.RowsAffected() checkErr(err) fmt.Println(affect) // query1 rows, err := db.Query("SELECT * FROM user_info") checkErr(err) for rows.Next() &#123; var uid int var username string err = rows.Scan(&amp;uid, &amp;username) checkErr(err) fmt.Println(uid) fmt.Println(username) &#125; //query2 var username, departname, created string err := db.QueryRow("SELECT username,departname,created FROM userinfo WHERE uid=?", 3).Scan(&amp;username, &amp;departname, &amp;created) //query3 查询一个 stmtOut, err := dbConn.Prepare("select author_id, name, display_ctime from video_infos where id = ?") if err !=nil&#123; return&#125; var aid int var dct, name string err = stmtOut.QueryRow(vid).Scan(&amp;aid, &amp;name, &amp;dct) defer stmtOut.Close() //query 4 查询多个 // delete stmt, err = db.Prepare("delete from user_info where id=?") checkErr(err) res, err = stmt.Exec(1) checkErr(err) // query rows, err = db.Query("SELECT * FROM user_info") checkErr(err) for rows.Next() &#123; var uid int var username string err = rows.Scan(&amp;uid, &amp;username) checkErr(err) fmt.Println(uid) fmt.Println(username) &#125; db.Close() &#125; func checkErr(err error) &#123; if err != nil &#123; panic(err) &#125;&#125; Nginx-rtmp+ffmpeg最近尝试着搭建了搭建一个基于RTMP协议 的流媒体服务器，我采用了Nginx流媒体服务器，并使用 ffmpeg 进行推流，成功推流本地视频到流媒体服务器上，可以正常播放。 https://www.jianshu.com/p/06c2025edcd3]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>beego</tag>
      </tags>
  </entry>
</search>
